#!/bin/sh
# We always use 'set -e' because it works "as expected" on the vast majority of
# POSIX shells out there .. BASH being the only exception. That said, it hurts
# nothing to use 'set -e' and then ignore its existance.
set -e

SHLIB_ONLY='false'
hascmd() { ! "${SHLIB_ONLY}" || return 1;test -e "`command -v "${1}"`" > /dev/null 2>&1; }
pathcmd() { hascmd "${1}" && command -v "${1}"; }

# Allow 'readonly' to work, even if it wont do what we want
if ! hascmd readonly > /dev/null 2>&1; then alias readonly=' ';fi

# Find the shell-flavor we are using
if ! ${ZSH_VERSION+false}; then
	readonly SHLIB_SHELL='zsh'
	emulate ksh
elif ! ${KSH_VERSION+false}; then
	readonly SHLIB_SHELL='ksh'
	alias type > /dev/null 2>&1 || alias type='whence -v'
elif ! ${BASH_VERSION+false}; then
	readonly SHLIB_SHELL='bash'
else
	readonly SHLIB_SHELL='sh'
fi

# Always request the shell obey POSIX
readonly POSIXLY_CORRECT=posix

##
# It tends to be faster to call these as functions vs searching the PATH and
# then fork/exec'ing them.  On the flip side, we only supply very low-level
# routines as part of the core shlib.  Everything else MUST be supplied via
# 'import' libraries.
dirname()
{
	case "${1}" in (.*);; (/*);; (*) set -- "./${1}";; esac
	set -- "${1%/*}"
	test -z "${1}" && set -- '/'
	echo "${1}"
}
basename()
{
	set -- "${1%/}"
	set -- "${1##*/}"
	test -z "${1}" && set -- '/'
	echo "${1}"
}
pathname()
{(
	if ! test -d "${1}"; then
		set -- "`dirname "${1}"`" "`basename "${1}"`"
	fi
	cd "${1}"
	if pwd -P > /dev/null 2>&1; then
		echo "`pwd -P`/${2}"
	else
		echo "`pwd`/${2}"
	fi
)}

##
# useful utility routines
error() { echo "error: $*" >&2; }
die() { error "$*"; exit 1; }

##
# shlib library routines
imported()
{
	shlib_imported_lib="$(printf '%s\n' "$1"|tr '/' '_')"
	shift
	set -- "${shlib_imported_lib}" "$@"
	unset shlib_imported_lib

	case "$#" in
	(1)	"shlib_import_$1" > /dev/null 2>&1 || return 1;;
	(2)	eval "shlib_import_$1() { echo '$2'; }";;
	(*)	return 1;;
	esac

	# We only get this far if $# == 2
	eval "shlib_imports() { echo '$(shlib_imports) $1'; }"
	return 0
}
import()
{
	SHLIB_IMPORT_LIB="${*}"
	shlib_import_ifs="${IFS}"
	IFS=':'
	set -- ${SHLIB_PATH}
	IFS="${shlib_import_ifs}"
	unset shlib_import_ifs

	shlib_import_file=
	for shlib_import_path; do
		if test -f "${shlib_import_path}/${SHLIB_IMPORT_LIB}.shlib"; then
			shlib_import_file="${shlib_import_path}/${SHLIB_IMPORT_LIB}.shlib"
		fi

		if test -e "${shlib_import_path}/${SHLIB_IMPORT_LIB}/__init__.shlib"; then
			shlib_import_file="${shlib_import_path}/${SHLIB_IMPORT_LIB}/__init__.shlib"
		fi
		test -z "${shlib_import_file}" || break
	done
	test -z "${shlib_import_file}" && die "invalid library '${SHLIB_IMPORT_LIB}'"
	SHLIB_IMPORT_FILE="`pathname "${shlib_import_file}"`"
	SHLIB_IMPORT_DIR="${SHLIB_IMPORT_FILE%/*}"
	unset shlib_import_file
	unset shlib_import_path

	# Only allow a library to be imported once per-scope
	! imported "${1}" || return 0

	# Mostly some fun debugging data
	SHLIB_IMPORT_OPWD="${PWD}"
	cd "${SHLIB_IMPORT_DIR}"

	SHLIB_CALL_STACK_OLD="${SHLIB_CALL_STACK}"
	SHLIB_CALL_STACK="${SHLIB_CALL_STACK} ${SHLIB_IMPORT_LIB}"
	. "${SHLIB_IMPORT_FILE}"
	SHLIB_CALL_STACK="${SHLIB_CALL_STACK_OLD}"
	cd "${SHLIB_IMPORT_OPWD}"

	unset SHLIB_CALL_STACK_OLD
	unset SHLIB_IMPORT_FILE
	unset SHLIB_IMPORT_DIR
	unset SHLIB_IMPORT_OPWD

	# Record that we imported the library
	imported "${1}" "${2}"
}

##
# These routines are pretty shlib specific.
alias shlib_main="! test \"\${SHLIB_CALL_STACK}\" = '__main__' || "
shlib_version() { echo '0.01'; }
shlib_usage()
{
	if test "$#" -gt '0'; then
		error "${2}"
		echo "try '${1} --help'" >&2
		exit 1
	fi
cat << EOF
usage: shlib [options] [file]

 options:
   -L, --libdir=LIBDIR
   -v, --verbose	Enable verbose execution
   -V, --version	Display shlib version
   -h, --help		Display this help

 shell opts:
   -c STRING		Execute commands given in STRING
   -x			Trace script execution
   --shlib-only		Only use shlib versions of commands

EOF
}
shlib_init()
{
	eval 'shlib_imports() { :; }'
	if ! hascmd let; then let() { IFS=, command eval test '$(($*))' -ne 0; }; fi
	if hascmd seq; then
		seq() { command seq "$@"; }
	else
		seq()
		{
			test "$#" -eq 1 && set -- 1 "${1}"
			test "$#" -eq 2 && set -- "${1}" 1 "${2}"
			test "$#" -gt 3 && die "seq: extra operand '${4}'"
			while true; do
				if test "${2}" -gt '0'; then
					test "${1}" -lt "${3}" || break
				else
					test "${1}" -gt "${3}" || break
				fi
				echo "${1}"
				set -- "$((${1} + ${2}))" "${2}" "${3}"
				test "${1}" != "${3}" || break
			done
		}
	fi
	unset -f shlib_version
	unset -f shlib_usage
	unset -f shlib_init
}

# If we where not "installed" then this variable will not have been
# substituted, and the libexecdir in which we find the 'shlib' front-end will
# not exist at which point we expect libdir to be relative to ${0}.
# e.g. <path to shlib>/shlib, <path to shlib>/libexec/.
# Alternatively, an environment may set the SHLIB_PATH to place shlib in
# disparate locations.
# e.g. SHLIB_PATH="${TOPDIR}/utils/shlib/libexec" while 'shlib' exists as a
# symlink in "${TOPDIR}/bin/shlib"
if test -z "${SHLIB_PATH}"; then
	SHLIB_PATH="@shlib_libexecdir@"
	if ! test -d "${SHLIB_PATH}" && test -d "${0%/*}/libexec"; then
			SHLIB_PATH="`pathname "${0%/*}/libexec"`"
			readonly SHLIB_PATH="${SHLIB_PATH%/}"
	fi

	# Note: Checking for library validity is done at import(), this allows
	# setting SHLIB_PATH dynamically at runtime.
fi

# If our basename is 'shlib' then we are the master program, else we are likely
# being 'sourced' by some other script which wants to utilize shlib as a
# library.
if test "`basename "${0}"`" = 'shlib'; then
	while test "$#" -gt '0'; do
		case "${1}" in
		(-h|-help|--help)
			shlib_usage; exit 0;;

		(-V|-version|--version)
			echo "shlib version `shlib_version`"; exit 0;;

		(-L|-libdir|--libdir|--libdir=*)
			shlib_arg=
			if test "${1#--libdir=}" != "${1}"; then
				shlib_arg="${1#--libdir=}"
			else
				case "${2}" in (-*);; (*) shlib_arg="${2}";; esac
				shift
			fi

			if test -z "${shlib_arg}"; then
				shlib_usage 'shlib' "option '${1#--libdir=}' requires an argument"
			fi
			test -e "${shlib_arg}" || die "no such directory '${shlib_arg}'"
			test -d "${shlib_arg}" || die "not a directory '${shlib_arg}'"
			SHLIB_PATH="${shlib_arg}:${SHLIB_PATH}";;

		(--shlib-only)
			readonly SHLIB_ONLY=true;;

		# Support some traditional sh arguments.
		(-v)	set -v;;
		(-x)	set -x;;
		(-c)	test "$#" -gt '1' || \
				shlib_usage 'shlib' "option '${1}' requires an argument"
			SHLIB_COMMAND="${2}"
			shift;;

		# Our standard argument handling
		(--)	shift; break;;
		(-*)	shlib_usage 'shlib' "unknown option '${1}'";;
		(*)	break;;
		esac
		shift
	done

	# Initialize shlib
	shlib_init

	# Handle being called as 'shlib -c "<cmd>"'
	if ! test -z "${SHLIB_COMMAND}"; then
		SHLIB_CALL_STACK='__main__' eval "${SHLIB_COMMAND}"
	else # We are being "executed", so lets check our argument list.
		test "$#" -ne '0' || shlib_usage 'shlib' 'no script specified'
		test -f "`pathname "${1}"`" || die "file does not exist '${1}'"

		PROGNAME="`basename "${1}"`"
		SHLIB_SCRIPT="${1}"
		SHLIB_IMPORT_FILE="${SHLIB_SCRIPT}"
		SHLIB_IMPORT_DIR="${SHLIB_SCRIPT%/*}"
		SHLIB_IMPORT_PWD="${PWD}"
		shift

		SHLIB_CALL_STACK='__main__' . "${SHLIB_SCRIPT}"
	fi
fi
