#!/usr/bin/env shlib

import system
import string

__expect_init()
{
	__expect_tmpdir=
	__expect_stdin=
	__expect_stdout=
	__expect_stderr=
	__expect_pid=0
	__expect_timer=0
	__expect_timeout_val=60
}
__expect_init

__expect_timeout()
{
	: "__expect_timeout(): $*"
	__expect_timeout_val="${1}"
}
alias expect.timeout='__expect_timeout '

__expect_close()
{
	: "__expect_close(): $*"
	! test -f "${__expect_stdin}" || rm "${__expect_stdin}"
	! test -f "${__expect_stdout}" || rm "${__expect_stdout}"
	! test -f "${__expect_stderr}" || rm "${__expect_stderr}"
	! test -f "${__expect_tmpdir}/pid" || rm "${__expect_tmpdir}/pid"
	! test -d "${__expect_tmpdir}" || rmdir "${__expect_tmpdir}"

	# FIXME this is not entirely portable to all OS's
	if (cd '/proc/' && test -d "${__expect_pid}"); then
		kill "${__expect_pid}"
	fi

	if (cd '/proc/' && test -d "${__expect_timer}"); then
		kill "${__expect_timer}"
	fi

	__expect_init
}

__expect_spawn()
{
	: "__expect_spawn(): $*"

	! test -d "${__expect_tmpdir}" || die 'expect.spawn() process already running'

	__expect_tmpdir="$(system.mktempdir expect)"
	test -d "${__expect_tmpdir}" || die 'expect.spawn() failed to make tmp directory'

	shlib.atexit __expect_close

	__expect_stdin="${__expect_tmpdir}/in"
	system.mkifo "${__expect_stdin}" || die 'expect.spawn() failed to make stdin'

	__expect_stdout="${__expect_tmpdir}/out"
	system.mkifo "${__expect_stdout}" || die 'expect.spawn() failed to make stdout'

	__expect_stderr="${__expect_tmpdir}/log"
	touch "${__expect_stderr}"

	(exec "$@" 1> "${__expect_stdout}" 2> "${__expect_stderr}" < "${__expect_stdin}") &
	__expect_pid="$!"

	# FIXME this is not entirely portable to all OS's
	if (cd '/proc/' && test -d "${__expect_pid}"); then
		echo "${__expect_pid}" > "${__expect_tmpdir}/pid"

		# NOTE: For whatever reason the fifo's are effectively
		# "stalled" unless we perform an initial empty write.  This may
		# be an oddity of /bin/sh.
		echo '' > "${__expect_stdin}"
	fi
}
alias expect.spawn='__expect_spawn '

__expect_timer_start()
{
	: "__expect_timer_start(): $*"
	if (cd '/proc/' && test -d "${__expect_timer}"); then
		kill "${__expect_timer}" > /dev/null 2>&1
	fi
	trap return SIGALRM
	__expect_timer_parent="$$"
	(sleep "${__expect_timeout_val}" && kill -SIGALRM ${__expect_timer_parent}) > /dev/null 2>&1 &
	unset __expect_timer_parent
	if (cd '/proc/' && test -d "$!"); then
		__expect_timer="$!"
	fi
	return 0
}

__expect_timer_stop()
{
	trap '' SIGARLM
	(cd '/proc/' && test -d "${__expect_timer}") && kill "${__expect_timer}" > /dev/null 2>&1
	__expect_timer='0'
	return 0
}

__expect_line()
{
	: "__expect_line(): $*"
	printf '%s\n' "${__expect_read_val}"
}
alias expect.line='__expect_line '

__expect_read()
{
	: "__expect_read(): $*"
	__expect_timer_start
	if read __expect_read_val < "${__expect_stdout}"; then
		__expect_line
		__expect_timer_stop
		return 0
	fi
	__expect_timer_stop
	return 1
}
alias expect.read='__expect_read '

__expect_match()
{
	: "__expect_match(): $*"
	while __expect_read; do
		if string.match "${1}" "$(__expect_line)"; then
			__expect_line
			return 0
		fi
	done
	return 1
}
alias expect.match='__expect_match '

__expect_regexp()
{
	:"__expect_regexp(): $*"
	while __expect_read; do
		if string.regexp "${1}" "$(__expect_line)"; then
			__expect_line
			return 0
		fi
	done
	return 1
}
alias expect.regexp='__expect_regexp '

__expect_write()
{
	: "__expect_write(): $*"
	printf '%s\n' "$*" > "${__expect_stdin}"
}
alias expect.write='__expect_write '

# vim: filetype=sh
